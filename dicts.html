<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Страница может иметь проблемы в связи с использованием ранней версии pyscript">
    <meta name="author" content="fbdayy">
    <meta name="reply-to" content="fbdayy@gmail.com">
    <meta http-equiv="content-language" content="ru">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <link href="style.css" rel="stylesheet" type="text/css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script defer>
hljs.highlightAll();
</script>
    <title>Самый подробный гайд по словарям на питоне</title>
<style>
</style>
</head>
<body>
    <div class="header purplebg">
        <p>Самая милая и офигенная шапка</p>
    </div>
    <h1 class="first">
        Словари и их методы
    </h1>
    <div class="c">
        <div class="inner-cont">
        <p>
            Словарь <code class="marked greenbg" lang="en">dict</code> – коллекция произвольных объектов с доступом по ключу</code>
        </p>
        <p>
            Ключ <code class="marked greenbg" lang="en">key</code> – строка, число или кортеж
        </p>
        <p>
            Значение <code class="marked greenbg" lang="en">value</code> – любой тип данных
        </p>
        <p>
            Элемент <code class="marked greenbg" lang="en">item</code> – кортеж вида <code lang="en">(key, value)</code>
        </p>
        </div>
        <div class="inner-cont">
        <br>
        <a href="#block1" class="a1">Создание словаря</a>
        <a href="#block1.1" class="a2"> Классический способ</a>
        <a href="#block1.2" class="a2"> Генератор</a>
        <a href="#block1.3" class="a2"> Функция <code lang="en">dict()</code></a>
        <br>
        <a href="#block2" class="a1">Методы словарей</a>
        <div id="block1" class="block">
            <h1>
                Создание словаря
            </h1>
            <div id="block1.1" class="block">
            <div class="inner-cont">
            <h2>
                1. Классика
            </h2>
            <p class="sticker greenbg">
                Словарь можно создать  литералом, поэтому любое выражение вида <code lang="en">{key1: value1, key2: value2}</code> можно по праву считать словарём. Пустой словарь можно создать любым из предложенных далее способов, оставив незаполненным поле для аргумента
            </p>
            <p>
                Да, именно поэтому так – {} невозможно создать пустое множество. Эта ниша уже занята словарями
            </p>
            <p>
                Итак, литерал – это сильнейший способ для создания короткого словаря, но наиболее бесполезный для словарей большего размера. Для примера создадим словарь, содержащий информацию об именах работников компании из разных офисов
            </p>
            <br>
            <p lang="en">
                Python:
            </p>
            <div class="pycode">
                <pre><code class="python">offices = {'office 1': ['Igor', 'Nataly'], 'office 2': ['Ann', 'Kirill']}

print(offices)</code></pre></div>
            <br>
            <p>
                Вывод:
            </p>
            <div class="pycode"><pre><code class="python">{'office 1': ['Igor', 'Nataly'], 'office 2': ['Ann', 'Kirill']}</code></pre></div>
            <br>
            <p>
                Сразу заметен огромный минус этого способа: им невозможно заполнить большое количество данных. В связи с этим, можно считать, что литералы рационально использовать только для создания словарей длиной не более пары десятков элементов
            </p>
            <p>
                Что делать с большим количеством данных мы узнаем в следующих блоках
            </p>
            </div>
            </div>
            <div id="block1.2" class="block">
            <div class="inner-cont">
            <h2>
                2. Генераторы словарей
            </h2>
            <p>
                Предположим, нам надо описать функцию <code lang="en" class="marked pinkbg">y = x² - 1</code> для всех целочисленных <code lang="en">x</code> на отрезке <code class="marked pinkbg">[1, 5]</code>. Это можно сделать собственноручно. Однако что, если отрезок увеличить в несколько раз? Способ уже не будет столь эффективен, зато точно покажется вам крайне монотонным и скучным. Никому не хочется часами выполнять рутинную работу. Именно поэтому и существуют генераторы
            </p>
            <p class="sticker greenbg">
                По природе своей генератор словаря почти ничем не отличается от генератора того же списка. Разница лишь в том, что для него необходимо указывать не только значение, но и ключ
            </p>
            <p>
                Предложенную выше математическую функцию мы можем описать следующим образом:
            </p>
            <div class="pycode"><pre><code class="python">dots = {x: x ** 2 - 1 for x in range(1, 6)}

print(dots)</code></pre></div>
            <br>
            <p>
                Вывод:
            </p>
            <div class="pycode"><pre><code class="python">{1: 0, 2: 3, 3: 8, 4: 15, 5: 24}</code></pre></div>
            <p>
                Теперь в словаре для любой целочисленной абциссы на заданном отрезке будет храниться её ордината, что позволит получить значение функции, просто обратившись к словарю. Достаточно увеличить диапазон генерации и тут же ваш словарь станет в несколько раз содержательнее
            </p>
            <p>
                Плюс этого способа заключается в том, что для любой зависимости, поддающейся функциональному описанию, можно сгенерировать элемент при помощи компьютерных вычислений. Таким образом мы способны обрабатывать большое количество информации за короткий срок
            </p>
            <p class="sticker bluebg">
                Отлично, мы разобрались с тем, как быстро создать осмысленный словарь при помощи только что написанной функии. Но что делать, если элементы у нас уже есть, только записаны они в другом типе данных? Неужели придётся использовать циклы? Не придётся, ведь именно для таких случаев и припасена ещё одна коварная функция...
            </p>
            </div>
            </div>
            <div id="block1.3" class="block">
            <div class="inner-cont">
                <h2>
                    3. Функция <span lang="en">dict()</span>
                </h2>
                <p>
                    Функция создаёт элементы словаря из произвольного количества упорядоченных пар. Приведём пример присвоения идентификационных номеров работникам из разных офисов
                </p>
                <br>
                <div class="pyexample">
                <p class="example">
                    Python:
                </p>
                <button type="button" onclick="copy_data(example3)">copy</button>
                </div>
                <div class="pycode"><pre><code class="python" id="example3">workers = dict([("Ann", 1), ("Igor", 2), ("Kirill", 3), ("Nataly", 4)])
#workers = dict(Ann=1, Igor=2, Kirill=3, Nataly=4)

print(workers)</code></pre></div>
            <br>
            <p>
                Вывод:
            </p>
            <div class="pycode"><pre><code class="python">{'office 1': ['Igor', 'Nataly'], 'office 2': ['Ann', 'Kirill']}</code></pre></div>
                <p>
                    Обращаем внимание на то, что кавычки в последнем из примеров не нужны
                </p>
            </div>
            </div>
        </div>
    </div>
<script>
function copy_data(containerid) {
  var range = document.createRange();
  range.selectNode(containerid); //changed here
  window.getSelection().removeAllRanges(); 
  window.getSelection().addRange(range); 
  document.execCommand("copy");
  window.getSelection().removeAllRanges();
}
</script>
</body>
</html>
