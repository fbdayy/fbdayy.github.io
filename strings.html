<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Строка – итерируемый и неизменяемый текстовый тип данных. Нужно уметь отличать их от чисел...">
    <meta name="author" content="fbdayy">
    <meta name="reply-to" content="fbdayy@gmail.com">
    <meta http-equiv="content-language" content="ru">
    <link rel="icon" href="https://fbdayy.github.io/web/images/favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <link href="style.css" rel="stylesheet" type="text/css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script defer>
hljs.highlightAll();
</script>
    <title>Самый подробный гайд по строкам на питоне</title>
<style>
</style>
</head>
<body>
    <div class="header purplebg">
    <p><a href="/index" class="awhite" target="_blank">На главную</a></p><p><a href="/dicts" class="awhite" target="_blank">Словари</a></p>
    </div>
    <h1 class="first">
        Всё о строках
    </h1>
    <div class="c">
        <div class="inner-cont">
        <p>
            <span class="marked greenbg">Пояснение</span>. Запись вида <code>[,a]</code> означает, что параметр a необязателен, заполнен автоматически и изменяется увеличением числа аргументов. Запись вида <code>-> b</code> указывает на тип данных, возвращаемых функцией или методом. Индексами, длиной и шагом всегда являются целые числа. <code>bool</code> – логический тип данных, <code>list</code> – список
        </p>
        <p>
            Строка <code class="marked greenbg" lang="en">str</code> – итерируемый и неизменяемый текстовый тип данных </code>
        </p>
        <p class="sticker redbg">
            Необходимо уметь отличать строки от чисел, поскольку внешне они могут быть очень схожи. При вызове строки в стандартном <code lang="en">shell</code> всегда будут появляться кавычки, чего никогда не произойдёт с числом. Строка: "25", число: 25</p>
            <p class=" sticker redbg">Поскольку каждый символ строки кодируется отдельно от других, строкам есть разница между регистрами символов и языками. И символ э не будет равен символу Э, а английская <span lang="en">a</span> не будет равна русской а
        </p>
        </div>
        <div class="inner-cont">
        <a href="#block1" class="a1 a">Содержание строки</a>
        <a href="#block1.1" class="a2 a">Спецсимволы</a>
        <a href="#block1.2" class="a2 a">Кавычки</a>
        <a href="#block1.3" class="a2 a">Индексация</a>
        <br>
        <a href="#block2" class="a1 a">Создание строки</a>
        <a href="#block2.1" class="a2 a">Классический способ</a>
        <a href="#block2.2" class="a2 a">Функция <code lang="en">str()</code></a>
        <br>
        <a href="#block3" class="a1 a">Взаимодействия</a>
        <a href="#block3.1" class="a2 a">Срезы</a>
        <a href="#block3.2" class="a2 a">Редактирование</a>
        <a href="#block3.3" class="a2 a">Логика и сравнение</a>
        <a href="#block3.4" class="a2 a">Методы</a>
        <a href="#block3.5" class="a2 a">Функции</a>
        <br>
        <div class="block" id="block1">
            <h1>
                Содержание строк
            </h1>
            <div id="block1.1" class="block">
            <div class="inner-cont">
            <h2>
                1. Спецсимволы
            </h2>
            <a href="#input1" class="a2 a">Вниз к примеру</a>
            <p>
            <p class="sticker bluebg">
                Стоит предупредить, что далее представлены не все спецсимволы, а лишь те, что используются чаще всего
            </p>
            <p>
                Наличие символа <code class="marked greenbg" lang="en">r</code> перед строкой отменяет действие спецсимволов, превращая всё содержимое внутри кавычек в текст. Примерно так: <code class="marked greenbg" lang="en">r"\"</code>
            </p>
            <p>
                Наличие символа <code class="marked greenbg" lang="en">b</code> перед строкой превращает всё содержимое внутри строки в байты. Примерно так: <code class="marked greenbg" lang="en">b"text"</code>
            </p>
            <p>
            <code class="marked greenbg" lang="en">\n</code> – перенос строки
            </p>
            <p>
            <code class="marked greenbg" lang="en">\t</code> – горизонтальная табуляция. Горизонтально разделяет элементы автоматически подобранным количеством пробелов
            </p>
            <p>
            <code class="marked greenbg" lang="en">\v</code> – вертиральная табуляция. Вертикально разделяет элементы автоматически подобранным количеством пробелов
            </p>
            <p>
            <code class="marked greenbg" lang="en">\\</code> – символ \
            </p>
            <p class="sticker bluebg">
                Все три следующих символа нужны для работы с кавычками внутри строк, созданных теми же кавычками. Напомним, использование описанных на странице спецсимволов приведено в примере снизу, ссылки на который окружают этот блок
            </p>
            <p>
            <code class="marked greenbg" lang="en">\"</code> – символ "
            </p>
            <p>
                <code class="marked greenbg" lang="en">\'</code> – символ '
            </p>
            <p>
                <code class="marked greenbg" lang="en">\`</code> – символ `
            </p>
        </div>
        </div>
        <div id="block1.2" class="block">
            <div class="inner-cont">
            <h2>
                2. Кавычки
            </h2>
            <a href="#input1" class="a2 a">Вниз к примеру</a>
            <p>
                Строка обозначается одинарными <code class="marked greenbg" lang="en">'</code> или двойными <code class="marked greenbg" lang="en">"</code> кавычками по краям. Иногда бывает такое, что текст тоже должен содержать кавычки. Чаще всего, чтобы не прибегать к использованию спецсимволов, люди просто меняют кавычки и всё обходится. Но как быть, когда в тексте должны быть и те, и другие кавычки? На самом деле, строка может вместить в себя целый текст каким бы разнообразным он ни был. Для этого существует вариант создания текстового блока. Создать блок можно, троекратно повторив кавычки, открывающие и закрывающие строку. Теперь строка будет сохранять все символы переноса и не будет так требовательна к одиноким или даже парным кавычкам 
            </p>
        </div>
        </div>
        <div id="block1.3" class="block">
            <div class="inner-cont">
            <h2>
                3. Индексация
            </h2>
            <a href="#input2" class="a2 a">Вниз к примеру</a>
            <p>
            <p>
                На самом деле, любой символ строки в питоне нумеруется. Этот номер символа и называется его <span class="marked greenbg">индексом</span>. Фишка программистов в том, что <span class="marked greenbg">индексация идёт с нуля</span>. Для удобства любой поддающийся индексации элемент пронумерован с двух сторон. Если визуализировать это, мы получим примерно следующее
            </p>
            <div class="img_wrapper">
                <img src="https://fbdayy.github.io/web/images/indexing.png" alt="indexing.png">
            </div>
            <p>
                Само слово начинается с нуля. Поэтому индекс 0: первый символ, 1: второй символ и т. д. Но слово продублировано, и мы можем пойти в обратную сторону примерно так: –1: последний символ, –2: предпоследний и т. д. Поэтому слово в примере ограничивается индексами -5 и 4
            </p>
            <p>
                Обратиться к элементу по индексу мы можем, написав его в квадратных скобках после вызова самого элемета. В случае со строкой это буква. Делается это вот так: <code class="marked greenbg">"слово"[0]</code> <span class="marked redbg">без пробела после слова</span>. Таким вызовом мы получим букву о
            </p>
            <p class="sticker redbg">
                С индексами нужно быть осторожным, поскольку попытка обратиться к несуществующему индексу обязательно закончится ошибкой. Чаще всего люди забывают о том, что для элемента длиной 5 последний индекс будет 4, и постоянно ловят одну и ту же ошибку
            </p>
            <p>
                В нашем случае попытка призвать <span class="red">"слово"[5]</span> закончится тем, что будет брошена <code class="red">IndexError: string index out of range</code>
            </p>
            </div>
            </div>
            </div>
        <div id="block2" class="block">
            <h1>
                Создание строки
            </h1>
            <div id="block2.1" class="block">
            <div class="inner-cont">
            <h2>
                1. Классика
            </h2>
            <p class="sticker greenbg">
                Строку можно создать  литералом, поэтому любое выражение вида <code lang="en">"text"</code> или <code lang="en">'text'</code> можно по праву считать строкой. Пустую строку можно создать любым из предложенных способов, оставив незаполненным поле для аргумента
            </p>
            </div>
            </div>
            <div id="block2.2" class="block">
            <div class="inner-cont">
            <h2>
                2. Функция <code lang="en">str()</code>
            </h2>
            <p>
            <code class="marked greenbg" lang="en">str([,any])</code> <code>-> str</code> – функция, создающая строку из любого типа данных. При незаполнении any создаётся пустая строка
            </p>
            <div class="pyexample">
                <p class="example" lang="en">
                    Input
                </p>
                <button type="button" class="copybutton" onclick="copy_data(input1)" aria-label="Скопировать ввод второго примера"></button>
            </div>
                <div class="pycode"><pre><code class="python" id="input1" lang="en">word1 = '"слово"'
word2 = '23'
word3 = "'слово'"

print("word1: ", word1, '\n', "word2: ", word2, '\n', "word3: ", word3, sep="", )

print()
print('Те же строки другим способом')
print()

word1 = "\"слово\""
word2 = str(23)
word3 = '\'слово\''

print("word1: ", word1, '\n', "word2: ", word2, '\n', "word3: ", word3, sep="", )

print()
print('Изменили строки')
print()

word1 = "Перенос\nстроки"
word2 = """Это блок цельного текста.
Я могу переносить строку
Писать кавычки
"'"'"'"'"'"'"'"'"'"'"
"конь" == 'конь' 
Пропускать строки и начинать не с начала

           кря"""
word3 = '''С одинарными кавычками так тоже можно

           ква'''

print("word1: ", word1, '\n', "word2: ", word2, '\n', "word3: ", word3, sep="")

print()
print('Изменили строки')
print()

word1 = '''Демонстрация табуляции
Сейчас вы увидите, как один символ равномерно разделяет строки разной длины
Чай\tКофе
Сахар\tПеченьки
Я\tТы'''
word2 = str(3.1415)
word3 = str([3, 4])

print("word1: ", word1, '\n', "word2: ", word2, '\n', "word3: ", word3, sep="")

print()
print('Изменили строки')
print()

word1 = str({1: 4})
word2 = str(None)
word3 = str(True)

print("word1: ", word1, '\n', "word2: ", word2, '\n', "word3: ", word3, sep="")

print()
print('И т. д.')</code></pre></div>
            <br>
            <div class="pyexample">
            <p class="example" lang="en">
                Output
            </p>
            <button type="button" class="copybutton" onclick="copy_data(output2)" aria-label="Скопировать вывод второго примера"></button>
            </div>
            <div class="pycode" id="output2"><pre><code class="python" lang="en">word1: "слово"
word2: 23
word3: 'слово'

Те же строки другим способом

word1: "слово"
word2: 23
word3: 'слово'

Изменили строки

word1: Перенос
строки
word2: Это блок цельного текста.
Я могу переносить строку
Писать кавычки
"'"'"'"'"'"'"'"'"'"'"
"конь" == 'конь'
Пропускать строки и начинать не с начала

           кря
word3: С одинарными кавычками так тоже можно

           ква

Изменили строки

word1: Демонстрация табуляции
Сейчас вы увидите, как один символ равномерно разделяет строки разной длины
Чай     Кофе
Сахар   Печеньки
Я       Ты
word2: 3.1415
word3: [3, 4]

Изменили строки

word1: {1: 4}
word2: None
word3: True

И т. д.</code></pre></div>
            <p class="sticker bluebg">
                Да, строки – действительно крутая штука. Но это не всё, что с ними можно делать. Это было только начало
            </p>
            </div>
            </div>
            <div class="block" id="block3">
            <h1>
                Взаимодействия
            </h1>
            <div id="block3.1" class="block">
            <div class="inner-cont">
            <h2>
                1. Срезы
            </h2>
            <a href="#input2" class="a2 a">Вниз к примеру</a>
            <p>
            <p>
                <span class="marked greenbg">Срез</span> по сути является множественной индексацией. Выглядит он следующим образом:
            <code class="marked greenbg">str[[,start]:[,end]:[,step]]</code> <code>-> str</code>, где start – начальный индекс, end – конечный индекс, step – шаг. Сложная конструкция, но понимать её необходимо
            </p>
            <p>Во-первых, наличие пробелов в срезе вокруг двоеточия не критично, но и не желательно, если вы хотите соблюдать стандарты pep8
            </p>
            <p>Во-вторых, как бы то ни было странно, отличительной особенностью среза является двоеточие, а не числа. По стандарту начало – первый символ строки, конец – последний символ в направлении движения, шаг: 1. Мы можем не указывать некоторые параметры среза, если не хотим их менять, но мы обязаны обозначить двоеточием их место в срезе. Поскольку конец определяется автоматически, изначально это последний символ, но при срезе строки в обратном направлении он станет первым символом
            </p>
            <p>В-третьих, при указании конец среза (в отличие от начала) не включается в сам срез. Поэтому если вы хотите срезать первые два символа строки, то верным будет не такой вариант: <code class="red">str[:1]</code>, а вот такой <code class="marked greenbg">str[:2]</code>. Даже если строка состоит всего из двух символов и последним индексом у нас будет единица, мы всё равно обозначаем конец двойкой, хотя такого индекса и не существует на самом деле
            </p>
                <div class="pyexample">
                <p class="example" lang="en">
                    Input
                </p>
                <button type="button" class="copybutton" onclick="copy_data(input2)" aria-label="Скопировать ввод второго примера"></button>
                </div>
                <div class="pycode"><pre><code class="python" id="input2" lang="en">word = "электростанция"
print("Слово:", word)

#i – индекс буквы
i = 0

print(f"Буква с индексом {i}:", word[i],  sep='\t')
print(f"Буква с индексом {i + 1}:", word[i + 1],  sep='\t')
print(f"Буква с индексом {i - 1}:", word[i - 1], sep='\t', end='\n\n')

#a – срез. Все предложенные до печати варианты написания равны
a = word[:]
#a = word[::]
#a = word[::1]
#a = word[0:]
#a = word[0::]
#a = word[0::1]


print("Полный срез:", a, sep='\t', end='\n\n')

#start – индекс начала, end – индекс конца, step – шаг

start, end, step = 0, None, 2
a = word[start:end:step]

print("Каждый чётный символ")
print(f"word[{start}:{end}:{step}] =", a, end="\n\n")

start, end, step = 1, None, 2
a = word[start:end:step]

print("Каждый нечётный символ")
print(f"word[{start}:{end}:{step}] =", a, end="\n\n")

start, end, step = -1, None, -1
a = word[start:end:step]

print("Задом наперёд")
print(f"word[{start}:{end}:{step}] =", a, end="\n\n")

start, end, step = 1, -1, 3
a = word[start:end:step]

print("От второго до предпоследнего с шагом 3")
print(f"word[{start}:{end}:{step}] =", a)</code></pre></div>
            <br>
            <div class="pyexample">
            <p class="example" lang="en">
                Output
            </p>
            <button type="button" class="copybutton" onclick="copy_data(output2)" aria-label="Скопировать вывод второго примера"></button>
            </div>
            <div class="pycode"><pre><code class="python" id="output3">Слово: электростанция
Буква с индексом 0:     э
Буква с индексом 1:     л
Буква с индексом -1:    я

Полный срез:    электростанция

Каждый чётный символ
word[0:None:2] = эетотни

Каждый нечётный символ
word[1:None:2] = лкрсаця

Задом наперёд
word[-1:None:-1] = яицнатсорткелэ

От второго до предпоследнего с шагом 3
word[1:-1:3] = лтсн</code></pre></div>
                <p>
                    Но и это ещё не всё. Самое лучшее оставили напоследок
                </p>
            </div>
            </div>
            <div id="block3.2" class="block">
            <div class="inner-cont">
            <h2>
                2. Редактирование
            </h2>
            <a href="#input3" class="a2 a">Вниз к примеру</a>
            <p>
                Строки можно складывать и даже умножать. делается это так: <code class="marked greenbg">str1 + str1</code> и так: <code class="marked greenbg">str * int</code>. Порядок не важен. Вычитать и делить строки мы не можем
            </p>
            <p>
                Для повторного присвоения можно использовать операторы <code class="marked greenbg">*=</code> или <code class="marked greenbg">*=</code>. Но можно присвоить строке новое значение, призвав и изменив её
            </p>
            <p>
                Строка поддаётся форматированию. Если написать перед кавычками символ f, то внутри строки конструкции вида <code>{a}</code> будут замяняться на значение переменной a. Выглядит это так: <code class="marked">f"text {a} text{a}text"</code>. Вместо любой из a можно подставить любую другую переменную. Аналогичное действие совершает функция <a href="#format" class="a" style="display: inline"><code>format()</code></a>
            </p>
            </div>
            </div>
            <div id="block3.3" class="block">
            <div class="inner-cont">
            <h2>
                3. Логика и сравнение строк
            </h2>
            <p>
                Для возврата длины строки нам следует призвать функцию <code lang="en" class="marked greenbg">len(str)</code>. Эта функция считает все символы в строке, включая невидимые
            </p>
            <p>
                Любая непустая строка считается правдой. Притом даже невидимые символы считаются для строки её наполнением, поэтому строка, состоящая из пробела или переноса строки будет правдива. Тождественное сравнение строк совершается оператором <code lang="en" class="marked greenbg">==</code>. Хотя, куда важнее и интереснее сравнивать строки другими логическими операторами
            </p>
            <p class="sticker greenbg">
                Сравнение строк идёт посимвольно слева направо и большей считается та строка, у которой символ будет иметь больший код. Узнать код символа можно при помощи функции <a href="#ord" class="a" style="display: inline"><code>ord()</code></a>. Если сравниваемый символ один и тот же, сравниваются следующие символы. В случае, если ожна строка является началом другой больше будет строка большей длины. Иначе они будут равны
            </p>
            <p>
                Сравнение производится теми же логическими операторами, что и сравнение всего остального: <code lang="en" class="marked greenbg"><</code>, <code lang="en" class="marked greenbg"><=</code>, <code lang="en" class="marked greenbg">></code> и <code lang="en" class="marked greenbg">>=</code>
            </p>
            <p>
                Проверить вхождение одной строки в другую можно при помощи оператора <code lang="en" class="marked greenbg">in</code>. Напоминаем, что регистр при проверке учитывается
            </p>
            <div class="pyexample">
                <p class="example" lang="en">
                    Input
                </p>
                <button type="button" class="copybutton" onclick="copy_data(input3)" aria-label="Скопировать ввод третьего примера"></button>
                </div>
                <div class="pycode"><pre><code class="python" id="input3">aa = "чай"
b = "ник"
c = "Иван"

print(c + "-" + a)
print(a + b)
print(c[:-1])
print(b + ": " + c)
print(c + " – " + a + b + " :D")

print(f"Дважды два?", "2" * 2 + "!")
print(25 * "-")
print('чай' in 'случайно')
print("bool(' '):", bool(' '), sep='\t')

print("'a' > 'aa':", 'a' > 'aa', sep='\t')
print("'b' > 'aa':", 'b' > 'aa', sep='\t', end='\n\n')

a = ''
a += "3"
a *= 2
print(a)</code></pre></div>
            <br>
            <div class="pyexample">
            <p class="example" lang="en">
                Output
            </p>
            <button type="button" class="copybutton" onclick="copy_data(output3)" aria-label="Скопировать вывод третьего примера"></button>
            </div>
            <div class="pycode"><pre><code class="python" id="output3" lang="en">Иван-чай
чайник
Ива
ник: Иван
Иван – чайник :D
Дважды два? 22!
True
-------------------------
bool(' '):      True
'a' > 'aa':     False
'b' > 'aa':     True

33</code></pre></div>
            </div>
        </div>
        </div>
        <div class="block" id="block3.4">
        <div class="inner-cont">
            <h2>
                4. Методы
            </h2>
            <p class="sticker bluebg">
                В методах <code>start, end</code> и <code>step</code> работают так же, как и в <a href="#block3.1" class="a" style="display: inline; color: white; text-decoration: underline">срезе</a>
            </p>
            <a href="#input4" class="a2 a">Вниз к примеру</a>
            <br>
            <p>
                <code lang="en" class="marked greenbg">str.capitalize()</code> <code>-> str</code> – возвращает копию строки <code>str</code>, у которой первый символ заглавный, а остальные строчные
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.center(width, [,symb])</code> <code>-> str</code> – возвращает копию строки, заполненную до заданной длины <code>width</code> символом <code>symb</code> (автоматически – пробел), держа <code>str</code> посередине. При недостаточной длине циклично поочерёдно приклеивает символы по краям, начиная с правой стороны. Если длина строки изначально достаточна или превышает желаемую, строка не изменяется
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.count(sub[,start[,end]])</code> <code>-> int</code> – возвращает количество вхождений в строку <code>str</code> подстроки <code>sub</code> с начальным индексом <code>start</code> и конечным <code>end</code>
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.endswith(sub)</code> <code>-> bool</code> – проверяет, что <code>str</code> оканчивается подстрокой <code>sub</code> и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.find(sub[,start[,end]])</code> <code>-> int</code> – возвращает индекс первого символа подстроки <code>sub</code> с начальным индексом <code>start</code> и конечным <code>end</code> в строке <code>str</code>. Если не находит, возвращает -1
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.index(sub[,start[,end]])</code> <code>-> int</code> – возвращает индекс первого символа подстроки <code>sub</code> с начальным индексом <code>start</code> и конечным <code>end</code> в строке <code>str</code>. Если не находит, бросает <code class="red">ValueError</code>
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.isalnum()</code> <code>-> bool</code> – Проверяет, состоит ли строка <code>str</code> только из букв и цифр и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.isalpha()</code> <code>-> bool</code> – Проверяет, состоит ли строка <code>str</code> только из букв и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.isdigit()</code> <code>-> bool</code> – Проверяет, состоит ли строка <code>str</code> только из цифр и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.islower()</code> <code>-> bool</code> – Проверяет отсутствие в строке <code>str</code> заглавных символов и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.isspace()</code> <code>-> bool</code> – Проверяет, состоит ли строка <code>str</code> только из невидимых символов и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.istitle()</code> <code>-> bool</code> – проверяет, что строка <code>str</code> непустая и что все слова в ней начинаются с заглавной буквы, а продолжаются строчными, и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.join(list)</code> <code>-> str</code> – объединяет все элементы списка строк <code>list</code> в одну большую, внутри которой они разделены символом <code>str</code>, и возвращает получившуюся строку
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.ljust(width, [,symb])</code> <code>-> str</code> – возвращает строку <code>str</code>, дополненную до длины width символом <code>symb</code> (автоматически – пробел) с правой стороны
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.lower()</code> <code>-> str</code> – возвращает копию строки <code>str</code>, в которой все символы переведены в нижний регистр
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.lstrip([,chars])</code> <code>-> str</code> – возвращает копию строки удаляет <code>str</code>, у которой удалены с левой стороны все существующие в ней символы <code>chars</code> (автоматически – невидимые символы) до первого несоответствия
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.partition(sep)</code> <code>-> tuple</code> – раздляет копию строки <code>str</code> символами <code>sep</code> на две другие и возвращает кортеж вида <code>(str1, sep, str2)</code>, где <code>str1</code> – символы исэодной строки до разделителя, а <code>str2</code> – символы после
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.replace(sub, chars, [,count])</code> <code>-> str</code> – возвращает копию строки <code>str</code> и заменяет ней слева направо количество <code>count</code> сочетаний символов (автоматически: все сочетания) <code>sub</code> на символы <code>char</code>
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.rfind(sub[,start[,end]])</code> <code>-> int</code> – возвращает индекс первого символа подстроки <code>sub</code> с правой стороны с начальным индексом <code>start</code> и конечным <code>end</code> в строке <code>str</code>. Если не находит, возвращает -1
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.index(sub[,start[,end]])</code> <code>-> int</code> – возвращает индекс первого символа подстроки <code>sub</code> справа с начальным индексом <code>start</code> и конечным <code>end</code> в строке <code>str</code>. Если не находит, бросает <code class="red">ValueError</code>
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.rjust(width, [,symb])</code> <code>-> str</code> – возвращает копию строки <code>str</code>, дополненную до длины width символом <code>symb</code> (автоматически – пробел) с левой стороны
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.rpartition(sep)</code> <code>-> tuple</code> – раздляет копию строки <code>str</code> с правой стороны символами <code>sep</code> на две другие и возвращает кортеж вида <code>(str1, sep, str2)</code>, где <code>str1</code> – символы исходной строки до разделителя, а <code>str2</code> – символы после
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.rstrip([,chars])</code> <code>-> str</code> – возвращает копию строки <code>str</code> ииудаляет в ней с правой стороны все существующие символы из сочетания <code>chars</code> (автоматически – невидимые символы) до первого несоответствия
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.split([,sep])</code> <code>-> list</code> – разбивает копию строки <code>str</code> на другие подстроки разделителем <code>sep</code> (автоматически – пробел) и возвращает список из получившихся строк
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.endswith(sub)</code> <code>-> bool</code> – проверяет, что <code>str</code> начинается с подстроки <code>sub</code> и возвращает логический тип данных
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.strip([,chars])</code> <code>-> str</code> – возвращает копию строки <code>str</code>, у которой с обеих сторон удалены все существующие символы из подстроки <code>chars</code> (автоматически – невидимые символы) до первого несоответствия
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.swapcase()</code> <code>-> str</code> – возвращает копию строки <code>str</code>, меняя регистр каждого символа на противоположный
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.title()</code> <code>-> str</code> – возвращает копию строки <code>str</code>, в которой все слова начинаются с заглавной буквы, а продолжаются строчными
            </p>
            <p>
                <code lang="en" class="marked greenbg">str.upper()</code> <code>-> str</code> – возвращает копию строки <code>str</code>, в которой все символы переведены в верхний регистр
            </p>
            </div>
            </div>
            <div class="block" id="block3.5">
            <div class="inner-cont">
            <h2>
                5. Функции
            </h2>
            <p>
                <code lang="en" class="marked greenbg">chr(code)</code> <code>-> str</code> – возвращает символ с кодом <code>code</code> в кодировке ASCII
            </p>
            <p>
                <code lang="en" class="marked greenbg" id="ord">ord(symb)</code> <code>-> int</code> – возвращает код символа <code>symb</code> в кодировке ASCII
            </p>
            <div class="pyexample">
                <p class="example" lang="en">
                    Input
                </p>
                <button type="button" class="copybutton" onclick="copy_data(input4)" aria-label="Скопировать ввод последнего примера"></button>
                </div>
                <div class="pycode"><pre><code class="python" id="input4">text = "ВстуПив В бОЙ с шИпящими змЕями – эфОй и гадюкой, – МалЕнький, цЕпкий, храБРый ёж тоТчас съел Их."

print("text[1:11].capitalize() ", text[1:11].capitalize(), sep="\t")
print("text[:11].center(20, '*')", text[:11].center(20, '*'), sep="\t")

print()

print("text.count(' ')  ", text.count(' '), sep="\t")
print("text.endswith('.')", text.endswith('.'), sep="\t")

print()

print("text.find('ми', 29, 40)", text.find('ми', 29, 40), sep=" \t")
print("text.index('ми', 25, 40)", text.index('ми', 25, 40), sep="\t")

print()

print("text[:11].isalnum()", text[:11].isalnum(), sep="\t")
print("text[:11].isalpha()", text[:11].isalpha(), sep="\t")
print("text[:11].isdigit()", text[:11].isdigit(), sep="\t")
print("text[:11].islower()", text[:11].islower(), sep="\t")
print("text[:11].isspace()", text[:11].isspace(), sep="\t")
print("text[:11].istitle()", text[:11].istitle(), sep="\t")
print("text[:11].isupper()", text[:11].isupper(), sep="\t")

print()

print("text[:11].ljust(20, '*')", text[:11].ljust(20, '*'), sep="\t")

print()

print("text[:11].lower()", text[:11].lower(), sep="\t")
print("text[:11].lstrip('В б')", text[:11].lstrip('В б'), sep="\t")
print("text[:11].partition(' В ')", text[:11].partition(" В "), sep="\t")

print()

print("text[:11].replace('В', 'Кря ', 1)", text[:11].replace('В', 'Кря ', 1), sep="\t")

print()

print("text.rfind('ми', 29, 40)", text.rfind('ми', 29, 40), sep="\t")
print("text.rindex('ми', 25, 40)", text.rindex('ми', 25, 40), sep="\t")
print("text[:11].rjust(20, '*')", text[:11].rjust(20, '*'), sep="\t")
print("text[:11].rpartition(' В ')", text[:11].rpartition(" В "), sep="\t")

print()

print("text[:11].rstrip('В б')", text[:11].rstrip('В б'), sep="\t")
print("text[:11].split()", text[:11].split(), sep="\t")
print("text.startswith('Вст')", text.startswith("Вст"), sep="\t")
print("text[:9].strip('В')", text[:9].strip('В'), sep="\t")
print("text[:11].swapcase()", text[:11].swapcase(), sep="\t")
print("text[:11].title()", text[:11].title(), sep="\t")
print("text[:11].upper()", text[:11].upper(), sep="\t")

print()

print("chr(1054)", chr(1054), sep="\t")
print("len(text):", len(text), sep="\t")
print("ord('О'):", ord('О'), sep="\t")</code></pre></div>
            <br>
            <div class="pyexample">
            <p class="example" lang="en">
                Output
            </p>
            <button type="button" class="copybutton" onclick="copy_data(output4)" aria-label="Скопировать вывод последнего примера"></button>
            </div>
            <div class="pycode"><pre><code class="python" id="output4" lang="en">text[1:11].capitalize()         Ступив в б
text[:11].center(20, '*')       ****ВстуПив В б*****

text.count(' ')         17
text.endswith('.')      True

text.find('ми', 29, 40)         29
text.index('ми', 25, 40)        29

text[:11].isalnum()     False
text[:11].isalpha()     False
text[:11].isdigit()     False
text[:11].islower()     False
text[:11].isspace()     False
text[:11].istitle()     False
text[:11].isupper()     False

text[:11].ljust(20, '*')        ВстуПив В б*********

text[:11].lower()       вступив в б
text[:11].lstrip('В б') стуПив В б
text[:11].partition(' В ')      ('ВстуПив', ' В ', 'б')

text[:11].replace('В', 'Кря ', 1)       Кря стуПив В б

text.rfind('ми', 29, 40)        29
text.rindex('ми', 25, 40)       29
text[:11].rjust(20, '*')        *********ВстуПив В б
text[:11].rpartition(' В ')     ('ВстуПив', ' В ', 'б')

text[:11].rstrip('В б') ВстуПив
text[:11].split()       ['ВстуПив', 'В', 'б']
text.startswith('Вст')  True
text[:9].strip('В')     стуПив
text[:11].swapcase()    вСТУпИВ в Б
text[:11].title()       Вступив В Б
text[:11].upper()       ВСТУПИВ В Б

chr(1054)       О
len(text):      97
ord('О'):       1054</code></pre></div>
            </div>
        </div>
        </div>
    <p class="first">
        Нашли ошибку? Сообщите об этом нам. <a href="https://forms.yandex.ru/cloud/65bd5711693872387d8cfb7f/" class="a" style="display: inline" target="_blank">Форма обратной связи</a></p>
    </div>
    </div>
    <div class="footer greybg">
    <p><a href="https://t.me/fbdayy" class="awhite" target="_blank">Telegram</a></p><p><a href="https://github.com/fbdayy" class="awhite" target="_blank">Github</a></p><p><a href="https://vk.com/fbdayy" class="awhite" target="_blank">VK</a></p>
    </div>
<script async>
function copy_data(containerid) {
  var range = document.createRange();
  range.selectNode(containerid); //changed here
  window.getSelection().removeAllRanges(); 
  window.getSelection().addRange(range); 
  document.execCommand("copy");
  window.getSelection().removeAllRanges();
}
</script>
<script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
<script defer>
let bShow = document.querySelectorAll('button');

for (let i = 0; i < bShow.length; i++) {
  bShow[i].onclick = function(){
      swal("Copied", "", "success")
      ;}
}
</script>
</body>
</html>
