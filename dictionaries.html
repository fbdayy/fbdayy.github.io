<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Генератор словаря почти ничем не отличается от генератора того же списка. Разница лишь в том, что для него необходимо указывать не только значение, но и ключ">
    <meta name="author" content="fbdayy">
    <meta name="reply-to" content="fbdayy@gmail.com">
    <meta http-equiv="content-language" content="ru">
    <link rel="stylesheet" href="https://pyscript.net/alpha/pyscript.css" />
    <script defer src="https://pyscript.net/alpha/pyscript.js"></script>
    <title>Самый подробный гайд по словарям на питоне</title>
<style>
    :root{
        --mygreen: #f5fcf1;
        --myblue: #daeef9;
        --mygrey: #bfbcb8;
        --mygreen2: #00fd9e;
        --mypink: #f4dde6;
        /* f4dde6 f6f5f5 fbfbfb */
        --codebg: #fafafb;
    }

    html{
        font-family: 'Roboto', sans-serif;
    }
    
    @media (pointer:fine){
        :root{
            --myh1: 5ex;
            --myh2: 4ex;
            --myp: 3ex;
        }
    }

    @media (pointer:coarse){
        :root{
            --myh1: 4ex;
            --myh2: 3ex;
            --myp: 2ex;
        }
    }

    p{
        text-align: left;
        font-size: var(--myp);
    }

    h1{
        text-align: center;
        vertical-align: top;
        font-size: var(--myh1);
        margin-block-end: 40px;
    }
    
    h2{
        text-align: center;
        vertical-align: top;
        font-size: var(--myh2);
        margin-block-end: 40px;
    }

    a{
        text-align: center;
        color: #020250;
        display: block;
        text-decoration: none;
        position: relative;
        max-width: max-content;
    }
    
    a:hover {
        color: #020250;
    }
    
    a::before {
        content: "";
        position: absolute;
        display: block;
        width: 100%;
        height: 2px;
        bottom: 0;
        left: 0;
        background-color: #020250;
        transform: scaleX(0);
        transition: transform 0.3s ease;
    }
    a:hover::before {
        transform: scaleX(1);
    }
    
    .co{
        margin-top: 40px;
        margin-bottom: 40px;
        flex-direction: column;
    }

    .c{
        display: flex;
        flex-direction: column;
        align-items: top;
        justify-content: center;
        align-content: center;
    }
    
    .marked{
        padding: 1px 8px 1px 8px;
        border-radius: 30px;
    }
    
    .a1{
        font-size: var(--myh2);
        margin-bottom: 20px;
    }
    
    .a2{
        font-size: var(--myp);
        margin-bottom: 10px;
    }
    
    .inner-cont{
        padding: 5px 20px 5px 20px;
    }
    
    .sticker{
        padding: 30px;
        margin-top: 70px;
        margin-bottom: 70px;
        border-radius: 30px;
        box-shadow: 0px 0px 19px 11px rgba(71, 72, 73, 0.09);
    }
    
    .greenbg{
        background-color: var(--mygreen);
    }
    
    .green2bg{
        background-color: var(--mygreen2);
    }
    
    .bluebg{
        background-color: var(--myblue);
    }
    
    .pinkbg{
        background-color: var(--mypink)
    }

    .block{
        border-radius: 30px;
    }
    
    .block:target {
        animation: anim .5s;
    }
    
    @keyframes anim { 
        0%, 100% {background: rgba(0,0,0,0);}
        50% {background: #bbf2ff;}
    }
</style>
</head>
<body>
    <h1 class="h">
        Словари и их методы
    </h1>
    <div class="c">
        <div class="inner-cont">
        <p>
            Словарь <code class="marked green2bg" lang="en">dict</code> – коллекция произвольных объектов с доступом по ключу</code>
        </p>
        <p>
            Ключ <code class="marked green2bg" lang="en">key</code> – строка, число или кортеж
        </p>
        <p>
            Значение <code class="marked green2bg" lang="en">value</code> – любой тип данных
        </p>
        <p>
            Элемент <code class="marked green2bg" lang="en">item</code> – кортеж вида <code lang="en">(key, value)</code>
        </p>
        </div>
        <div class="inner-cont">
        <br>
        <a href="#block1" class="a1">Создание словаря</a>
        <a href="#block1.1" class="a2"> Классический способ</a>
        <a href="#block1.2" class="a2"> Генератор</a>
        <a href="#block1.3" class="a2"> Функция <code lang="en">dict()</code></a>
        <br>
        <a href="#block2" class="a1">Методы словарей</a>
        <div id="block1" class="block">
            <h1>
                Создание словаря
            </h1>
            <div id="block1.1" class="block">
            <div class="inner-cont">
            <h2>
                1. Классика
            </h2>
            <p class="sticker greenbg">
                Словарь можно создать  литералом. Это сильнейший способ для создания короткого словаря, но наиболее бесполезный для словарей большего размера. Поэтому любое выражение вида <code lang="en">{key1: value1, key2: value2}</code> можно по праву считать словарём
            </p>
            <p>
                Всеми приведёнными далее способами можно создать пустой словарь, оставив незаполненным поле для аргумента. Да, именно поэтому так – {} невозможно создать пустое множество. Эта ниша уже занята словарями
            </p>
            <p>
                Для примера создадим словарь, содержащий информацию об именах работников компании из разных офисов
            </p>
            <div class="co">
            <py-repl>
offices = {'office 1': ['Igor', 'Nataly'], 'office 2': ['Ann', 'Kirill']}

#Следующая строчка нужна для корректного вывода данных. id элемента: "p1"
pyscript.write("p1", offices)
            </py-repl>
            <br>
            <p id="p1">
                Здесь будет ваш вывод
            </p>
            </div>
            <p>
                Сразу заметен огромный минус этого способа: им невозможно заполнить большое количество данных. В связи с этим, можно считать, что литералы рационально использовать только для создания словарей длиной не более пары десятков элементов
            </p>
            <p>
                Что делать с большим количеством данных мы узнаем в следующих блоках
            </p>
            </div>
            </div>
            <div id="block1.2" class="block">
            <div class="inner-cont">
            <h2>
                2. Генераторы словарей
            </h2>
            <p>
                Предположим, нам надо описать функцию <code lang="en" class="marked pinkbg">y = x² - 1</code> для всех целочисленных <code lang="en">x</code> на отрезке <code class="marked pinkbg">[1, 5]</code>. Это можно сделать собственноручно. Однако что, если отрезок увеличить в несколько раз? Способ уже не будет столь эффективен, зато точно покажется вам крайне монотонным и скучным. Никому не хочется часами выполнять рутинную работу. Именно поэтому и существуют генераторы
            </p>
            <p class="sticker greenbg">
                По природе своей генератор словаря почти ничем не отличается от генератора того же списка. Разница лишь в том, что для него необходимо указывать не только значение, но и ключ. Предложенную выше математическую функцию мы можем описать следующим образом:
            </p>
            <div class="co">
            <py-repl>
dots = {x: x ** 2 - 1 for x in range(1, 6)}

pyscript.write("p2", dots)
            </py-repl>
            <br>
            <p id="p2">
                Здесь будет ваш вывод
            </p>
            </div>
            <p>
                Теперь в словаре для любой целочисленной абциссы на заданном отрезке будет храниться её ордината, что позволит получить значение функции, просто обратившись к словарю. Достаточно увеличить диапазон генерации и тут же ваш словарь станет в несколько раз содержательнее
            </p>
            <p>
                Плюс этого способа заключается в том, что для любой зависимости, поддающейся функциональному описанию, можно сгенерировать элемент при помощи компьютерных вычислений. Таким образом мы способны обрабатывать большое количество информации за короткий срок
            </p>
            <p class="sticker bluebg">
                Отлично, мы разобрались с тем, как быстро создать осмысленный словарь при помощи только что написанной функии. Но что делать, если элементы у нас уже есть, только записаны они в другом типе данных? Неужели придётся использовать циклы? Не придётся, ведь именно для таких случаев и припасена ещё одна коварная функция...
            </p>
            </div>
            </div>
            <div id="block1.3" class="block">
            <div class="inner-cont">
                <h2>
                    3. Функция <span lang="en">dict()</span>
                </h2>
                <p>
                    Функция создаёт элементы словаря из произвольного количества упорядоченных пар. Приведём пример присвоения идентификационных номеров работникам из разных офисов
                </p>
                <div class="co">
                <py-repl>
workers = dict([("Ann", 1), ("Igor", 2), ("Kirill", 3), ("Nataly", 4)])
#workers = dict(Ann=1, Igor=2, Kirill=3, Nataly=4)
pyscript.write("p3", workers)
                </py-repl>
                <br>
                <p id="p3">
                    Здесь могла бы быть ваша реклама :D
                </p>
                </div>
                <p>
                    Обращаем внимание на то, что кавычки в последнем из примеров не нужны
                </p>
            </div>
            </div>
        </div>
    </div>
</body>
</html>
