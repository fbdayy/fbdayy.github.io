<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Короткий и многообразный словарь можно создать при помощи функции...">
    <meta name="author" content="fbdayy">
    <meta name="reply-to" content="fbdayy@gmail.com">
    <meta http-equiv="content-language" content="ru">
    <title>Самый подробный гайд по словарям на питоне</title>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,300" rel="stylesheet" type="text/css">
</head>
<style>
    :root {
        --mygreen: #f5fcf1;
        --mypink: #f4dde6;
        --myblue: #daeef9;
        --mygrey: #bfbcb8;
    }

    @media (orientation: portrait) {
        .c{
            display: flex;
            flex-direction: column;
            align-items: top;
            justify-content: center;
            align-content: center;
        }
        
        .marked{
            padding: 1px 8px 1px 8px;
            border-radius: 30px;
        }
        
        p{
            margin: 0, 0, 15px, 0;
            text-align: left;
            font-size: 2ex;
            font-family: 'Roboto', sans-serif;
        }
        
        .co{
            border: 2px solid;
            overflow-x: scroll;
            overflow-y: scroll;
            text-align: left;
            border-radius: 30px;
            padding: 15px 20px 15px 20px;
        }
        
        .block{
            border-radius: 30px;
        }
        
        .block:target {
            animation: anim .5s;
        }
        
        @keyframes anim { 
            0%, 100% {background: rgba(0,0,0,0);}
            50% {background: #bbf2ff;}
        }
        
        .a1{
            font-size: 3ex;
            margin-bottom: 20px;
        }
        
        .a2{
            font-size: 2ex;
            margin-bottom: 10px;
        }
        
        h1{
            text-align: center;
            vertical-align: top;
            font-size: 4ex;
            margin-block-end: 40px;
            font-family: 'Roboto', sans-serif;
        }
        
        h2{
            text-align: center;
            vertical-align: top;
            font-size: 3ex;
            margin-block-end: 40px;
        }
        
        code{
            font-size: 2ex;
            white-space: nowrap;
        }
        
        .inner-cont{
            padding: 5px 20px 5px 20px;
        }
        
        .sticker{
            padding: 30px;
            margin-top: 70px;
            margin-bottom: 70px;
            border-radius: 30px;
            -webkit-box-shadow: 0px 0px 19px 11px rgba(71, 72, 73, 0.09);
            -moz-box-shadow: 0px 0px 19px 11px rgba(71, 72, 73, 0.09);
            box-shadow: 0px 0px 19px 11px rgba(71, 72, 73, 0.09);
        }
        
        :nth-child(-n + 1 of p.sticker){
            background-color: var(--mygreen);
        }
        
        :nth-child(2 of p.sticker){
            background-color: var(--myblue);
        }
        
        code.marked:nth-child(n){
            background-color: var(--mypink);
        }
        
        a{
            text-align: center;
            font-family: 'Roboto', sans-serif;
            text-decoration: none;
            color: #020250;
            display: block;
            position: relative;
            max-width: max-content;
        }
        
        a:hover {
            color: #020250;
        }
        
        a::before {
            content: "";
            position: absolute;
            display: block;
            width: 100%;
            height: 2px;
            bottom: 0;
            left: 0;
            background-color: #020250;
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        a:hover::before {
            transform: scaleX(1);
        }
    }
    
    @media (orientation: landscape) {
    }
</style>
<body>
    <h1 class="h">
        Словари и их методы
    </h1>
    <div class="c">
        <div class="inner-cont">
        <p>
            Словарь <code class="marked" lang="en">dict</code> – коллекция произвольных объектов с доступом по ключу
        </p>
        <p>
            Ключ <code class="marked" lang="en">key</code> – строка, число или кортеж
        </p>
        <p>
            Значение <code lang="en" class="marked">value</code> – любой тип данных
        </p>
        <p>
            Элемент <code lang="en" class="marked">item</code> – кортеж вида <code lang="en">(key, value)</code>
        </p>
        </div>
        <div class="inner-cont">
        <br>
        <a href="#block1" class="a1">Создание словаря</a>
        <a href="#block1.1" class="a2"> Классический способ</a>
        <a href="#block1.2" class="a2"> Генератор</a>
        <a href="#block1.3" class="a2"> Функция <code lang="en">dict()</code></a>
        <br>
        <a href="#block2" class="a1">Методы словарей</a>
        <div id="block1" class="block">
            <h1>
                Создание словаря
            </h1>
            <div id="block1.1" class="block">
            <div class="inner-cont">
            <h2>
                1. Классика
            </h2>
            <p class="sticker">
                Словарь можно создать, поместив необходимые элементы в фигурные скобки. Это сильнейший способ для создания короткого словаря, но наиболее бесполезный для словарей большего размера
            </p>
            <p>
                Создадим словарь, содержащий информацию об именах работников компании из разных офисов
            </p>
            <div class="co">
            <code lang="en">
                offices = {'office 1': ['Igor', 'Nataly'], 'office 2': ['Ann', 'Kirill']}<br>
            </code>
            </div>
            <p>
                Сразу заметен огромный минус этого способа: им невозможно заполнить большое количество данных. В связи с этим, можно считать, что способ рационально использовать только для создания словаря длиной не более пары десятков элементов
            </p>
            <p>
                Что делать с большим количеством данных мы узнаем в следующих блоках
            </p>
            </div>
            </div>
            <div id="block1.2" class="block">
            <div class="inner-cont">
            <h2>
                2. Генератор словарей
            </h2>
            <p>
                Предположим, нам надо описать функцию <code lang="en" class="marked">y = x² - 1</code> для всех целочисленных <code lang="en">x</code> на отрезке <code class="marked">[1, 5]</code>. Это можно сделать собственноручно. Однако что, если отрезок увеличить в несколько раз? Способ уже не будет столь эффективен, зато точно будет крайне монотонен и скучен. Никому не хочется часами выполнять рутинную работу. Именно поэтому и существуют генераторы
            </p>
            <p class="sticker">
                По природе своей генератор словаря почти ничем не отличается от генератора того же списка. Разница лишь в том, что для него необходимо указывать не только значение, но и ключ. Предложенную выше математическую функцию мы можем описать следующим образом:
            </p>
            <div class="co">
            <code lang="en">
                dots = {x: x ** 2 - 1 for x in range(1, 6)}<br>
                <br>
                <span class="red">#{1: 0, 2: 3, 3: 8, 4: 15, 5: 24}</span>
            </code>
            </div>
            <p>
                Теперь в словаре для любой целочисленной абциссы на заданном отрезке будет храниться её ордината, что позволит получить значение функции, просто обратившись к значению словаря. Достаточно увеличить диапазон генерации и тут же ваш словарь станет в несколько раз содержательнее
            </p>
            <p>
                Плюс этого способа заключается в том, что для любой зависимости, поддающейся функциональному описанию, можно сгенерировать элемент при помощи компьютерных вычислений. Таким образом мы способны обрабатывать большое количество информации за короткий срок
            </p>
            <p class=sticker>
                Отлично, мы разобрались с тем, как быстро создать осмысленный словарь при помощи только что написанной функии. Но что делать, если элементы у нас уже есть, только записаны они в другом типе данных? Неужели придётся использовать циклы? Не придётся, ведь именно для таких случаев и припасена ещё одна коварная функция...
            </p>
            </div>
            </div>
            <div id="block1.3" class="block">
            <div class="inner-cont">
                <h2>
                    3. Функция <span lang="en">dict()</span>
                </h2>
                <p>
                    Функция создаёт элементы словаря из произвольного количества упорядоченных пар. Если функция принимает на вход словарь, результатом будет тот же словарь, отсортированный по ключам. Приведём пример присвоения идентификационных номеров работникам из разных офисов
                </p>
                <div class="co">
                <code lang="en">
                    workers = dict([("Ann", 1), ("Igor", 2), ("Kirill", 3), ("Nataly", 4)])<br>
                    workers = dict(Ann=1, Igor=2, Kirill=3, Nataly=4)<br>
                    <br>
                    <span class="red">#{"Ann": 1, "Igor": 2, "Kirill": 3, "Nataly": 4}</span>
                </code>
                </div>
                <p>
                    Обращаем внимание на то, что кавычки в последнем из примеров не нужны
                </p>
            </div>
            </div>
        </div>
    </div>
</body>
</html>
